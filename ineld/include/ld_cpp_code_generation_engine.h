/*-*-c++-*-****f*********************************************************************************************************
* Copyright 2016 - 2023 Inesonic, LLC.
*
* This file is licensed under two licenses.
*
* Inesonic Commercial License, Version 1:
*   All rights reserved.  Inesonic, LLC retains all rights to this software, including the right to relicense the
*   software in source or binary formats under different terms.  Unauthorized use under the terms of this license is
*   strictly prohibited.
*
* GNU Public License, Version 2:
*   This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
*   License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later
*   version.
*
*   This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
*   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
*   details.
*
*   You should have received a copy of the GNU General Public License along with this program; if not, write to the Free
*   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
********************************************************************************************************************//**
* \file
*
* This header defines the \ref Ld::CppCodeGenerationEngine class.
***********************************************************************************************************************/

/* .. sphinx-project ineld */

#ifndef LD_CPP_CODE_GENERATION_ENGINE_H
#define LD_CPP_CODE_GENERATION_ENGINE_H

#include <QSharedPointer>
#include <QByteArray>
#include <QSet>
#include <QTemporaryFile>
#include <QSemaphore>

#include <ud_usage_data.h>

#include "ld_common.h"
#include "ld_function_database.h"
#include "ld_element_structures.h"
#include "ld_identifier.h"
#include "ld_identifier_container.h"
#include "ld_code_generation_engine.h"

namespace Model {
    class Status;
    class Api;
}

namespace Ud {
    class UsageData;
};

namespace Cbe {
    class CppCompilerDiagnostic;
};

namespace Ld {
    class CppCodeGenerator;
    class TranslationPhase;
    class RootElement;
    class IdentifierDatabase;
    class CodeGeneratorOutputTypeContainer;
    class CppContext;

    /**
     * C++ code generation engine.
     */
    class LD_PUBLIC_API CppCodeGenerationEngine:public CodeGenerationEngine {
        friend class CppContext;

        public:
            /**
             * Constructor.
             *
             * \param[in] codeGenerator The code generator that instantiated this class instance.
             *
             * \param[in] rootElement   The root element used during the translation.
             *
             * \param[in] outputFile    The name of the output file to be generated.
             *
             * \param[in] outputType    The type of output to be generated by this code generation engine.
             *
             * \param[in] exportMode    A value indicating the export mode to be used.
             *
             * \param[in] usageData     The usage data instance to use with this engine.
             */
            CppCodeGenerationEngine(
                CodeGenerator*                          codeGenerator,
                QSharedPointer<RootElement>             rootElement,
                const QString&                          outputFile,
                const CodeGeneratorOutputTypeContainer& outputType,
                CodeGeneratorOutputType::ExportMode     exportMode,
                Ud::UsageData*                          usageData
            );

            ~CppCodeGenerationEngine();

            /**
             * Method that can be called by a translator to add a header or PCH dependency.  This method can safely be
             * called multiple times for the same header.  Note that this method ultimately creates a list that is
             * provided to the \ref Ld::CppContext instance.  Use this method rather than the
             * Cbe::CppCompilerContext::setHeaderFiles or Cbe::CompilerContext::setPchFiles methods.
             *
             * \param[in] headerName The name of the header or PCH file.
             */
            void dependsOnHeader(const QString& headerName);

            /**
             * Method that can be called by a translator to add a library dependency.  This method can be safely called
             * multiple times for the same library.  Note that this method ultimately creates a list that is provided to
             * the \ref Ld::CppContext instance.  Use this method rather than the
             * Cbe::LinkerContext::setStaticLibraries or Cbe::LinkerContext::setDynamicLibraries methods.
             *
             * \param[in] libraryName The name of the library.
             */
            void dependsOnLibrary(const QString& libraryName);

            /**
             * Method you can call to add an operation checkpoint to the code.  Calling this method will cause a small
             * snippet of C++ code to be inserted that checks for abort and pause conditions.
             *
             * Do not call this method in the middle of an operation, only between operations.  Note that, on success,
             * this method will also start a new statement for the caller.
             *
             * \param[in] element The element to be tied to this operation.
             *
             * \return Returns true on success, returns false on error.
             */
            bool insertOperationCheckpoint(ElementPointer element);

            /**
             * Method you can call to add an operation checkpoint to the code.  Calling this method will cause a small
             * snippet of C++ code to be inserted that checks for abort and pause conditions.
             *
             * Do not call this method in the middle of an operation, only between operations.  Note that, on success,
             * this method will also start a new statement for the caller.
             *
             * \param[in] element          The element to be tied to this operation.
             *
             * \param[in] identifierHandle An identifier handle to be included at this checkpoint.
             *
             * \return Returns true on success, returns false on error.
             */
            bool insertOperationCheckpoint(ElementPointer element, Identifier::Handle identifierHandle);

            /**
             * Method you can use to access a context tied to this code generation engine.  You can use this context to
             * create the underlying C++ code as well as details of the compiler and linker configuration.
             *
             * \return Returns a reference to the underlying context.
             */
            CppContext& context();

            /**
             * Method you can use to access a context tied to this code generation engine.  You can use this context to
             * create the underlying C++ code as well as details of the compiler and linker configuration.
             *
             * \return Returns a reference to the underlying context.
             */
            const CppContext& context() const;

            /**
             * Method you can use to obtain a shared pointer to the context used to write the HTML and side-band data.
             *
             * \return Returns a shared pointer to the requested context.
             */
            QSharedPointer<CppContext> contextPointer() const;

            /**
             * Method you can use to define a new identifier.  This method also updates the identifier database tied to
             * the root element.
             *
             * \param[in] newIdentifier The new identifier to be created.  This method will take ownership of the
             *                          identifier.
            */
            void addIdentifier(Identifier* newIdentifier);

            /**
             * Method you can use to define a new identifier.  This method also updates the identifier database tied
             * to the root element.
             *
             * \param[in] newIdentifier The new identifier to be created.
             */
            void addIdentifier(QSharedPointer<Identifier> newIdentifier);

            /**
             * Method you can use to define a new identifier.  This method also updates the identifier database tied
             * to the root element.
             *
             * \param[in] newIdentifier The new identifier to be created.
             */
            void addIdentifier(const IdentifierContainer& newIdentifier);

            /**
             * Method you can use to define a new identifier in the current scope.  This method also updates the
             * identifier database tied to the root element.
             *
             * \param[in] text1     The user visible text for the identifier.
             *
             * \param[in] text2     The user visible subscript text for the identifier.
             *
             * \param[in] definedAs Value indicating where and how the identifier was defined.
             *
             * \param[in] dataType  The datatype of the identifier.
             */
            void addIdentifier(
                const QString&        text1,
                const QString&        text2,
                Identifier::DefinedAs definedAs,
                const DataType&       dataType = DataType()
            );

            /**
             * Method you can use to tie a new element to an identifier.
             *
             * \param[in] text1     The user visible text for the identifier.
             *
             * \param[in] text2     The user visible subscript text for the identifier.
             *
             * \param[in] element   The element to tie to this identifier.
             *
             * \return Returns true on success, returns false if the identifier is not currently defined in a visible
             *         scope.
             */
            bool tieElementToIdentifier(
                const QString& text1,
                const QString& text2,
                ElementPointer element
            );

            /**
             * Method you can use to obtain an identifier by name.  The method unwinds the scope until it can identify
             * the desired identifier.
             *
             * \param[in] text1 The user visible text for the identifier.
             *
             * \param[in] text2 The user visible subscript text for the identifier.
             *
             * \return Returns the requested identifier.  An empty identifier container will be returned if the
             *         requested identifier does not exist.
             */
            IdentifierContainer identifier(const QString& text1, const QString& text2);

            /**
             * Method you can use to obtain an identifier by name in or above a specified scope.  The method unwinds
             * the scope until it can identify the desired identifier.
             *
             * \param[in] text1           The user visible text for the identifier.
             *
             * \param[in] text2           The user visible subscript text for the identifier.
             *
             * \param[in] scopeIdentifier The identifier container of the desired identifier.  This is a shared pointer
             *                            to the element that defines the scope.
             *
             * \return Returns the requested identifier.  An empty identifier container will be returned if the
             *         requested identifier does not exist.
             */
            IdentifierContainer identifier(const QString& text1, const QString& text2, ElementPointer scopeIdentifier);

            /**
             * Method you can use to update the current scope.  Scope is maintained as a stack so this method pushes
             * a new scope onto the stack.
             *
             * \param[in] newParentScope The new parent scope.  This is a shared pointer to the element that defines
             *                           the scope.
             *
             * \param[in] forceThisScope If true, then variables should be created in this scope even if they exist in
             *                           a more global scope.
             */
            void pushNewScope(ElementPointer newParentScope, bool forceThisScope = false);

            /**
             * Method you can use to pop the current scope.  Scope is maintained as a stack so this method pops the
             * most recent scope from the stack.  The method will assert if we are currently at global scope.
             *
             * Note that popping scope will reset assignments back to R-values.
             */
            void popCurrentScope();

            /**
             * Method you can use to obtain the identifier representing the current scope.
             *
             * \return Returns an identifier container representing the current scope.  A pointer to the root element
             *         will be returned if we are at global scope.
             */
            ElementPointer currentScope() const;

            /**
             * Method you can use to determine if the current scope should be forced.
             *
             * \return Returns true if the current scope should be forced.  Returns false if the current scope should
             *         not be forced.
             */
            bool currentScopeIsForced() const;

            /**
             * Method you can use to clear the forced scope flag within the current scope.
             *
             * \param[in] nowNotForced If true, the scope will no longer be forced within the current scope.
             */
            void clearForcedScope(bool nowNotForced = true);

            /**
             * Method you can use to obtain a list of all the identifiers in a specific scope.
             *
             * \param[in] scope The identifier indicating the desired scope.
             *
             * \return Returns a list of all identifiers in this scope.
             */
            QList<IdentifierContainer> identifiersInScope(ElementPointer scope) const;

            /**
             * Method you can use to determine if we're currently at global scope.
             *
             * \return Returns true if we're at global scope.  Returns false if we are not at global scope.
             */
            bool atGlobalScope() const;

            /**
             * Method you can use to indicate that we're defining L-values.
             *
             * \param[in] nowAsLValue A flag holding true if we're assigning L-values.  A value of false indicates that
             *                        we're using variables as R-values.
             */
            void setAsLValue(bool nowAsLValue = true);

            /**
             * Method you can use to indicate that we're using variables as R-values.
             *
             * \param[in] nowAsRValue A flag holding true if we're assigning R-values.  A value of false indicates that
             *                        we're using variables as L-values.
             */
            void setAsRValue(bool nowAsRValue = true);

            /**
             * Method you can use to determine if we're currently using variables as L-values.
             *
             * \return Returns true if we're using variables as L-values.  Returns false if we're using variables as
             *         R-values.
             */
            bool asLValue() const;

            /**
             * Method you can use to determine if we're currently using variables as R-values.
             *
             * \return Returns true if we're using variables as R-values.  Returns false if we're using variables as
             *         L-values.
             */
            bool asRValue() const;

        protected:
            /**
             * Pure virtual method that returns the translation phase instance to be used.
             *
             * \return Returns a pointer to the currect translation phase instance.
             */
            TranslationPhase* createTranslationPhase() const final;

            /**
             * Method that is called to determine if all root imports should be used.  You should overload this method
             * to determine if root imports should be included.
             *
             * \return Returns true if all root imports should be included.  Returns false if only the main root
             *         element should be used.
             */
            bool includeRootImports() const final;

            /**
             * Method that calls the correct pre-translation method for the required translation.
             *
             * \param[in] translationPhase The translation phase to be performed.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preTranslate() final;

            /**
             * Method that calls the correct post-translation method for the required translation.
             *
             * \param[in] translationPhase The translation phase to be performed.
             *
             * \return Returns true on success, returns false on error.
             */
            bool postTranslate() final;

        private:
            /**
             * Method that is called just before querying the element tree to identify any and all required headers and
             * required static or dynamic libraries.
             *
             * This phase is also used to identify any varables types that are explicitly declared.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preIdentifyDependenciesAndExplicitTypes();

            /**
             * Method that is called just before querying the element tree to identify any and all types for elements
             * whose types have not been explicitly declared.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preIdentifyInferredTypes();

            /**
             * Method that is called when the translator starts inserting declarations.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preDeclarations();

            /**
             * Method that is called when the translator needs to insert model class declaration.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preModelClassDeclaration();

            /**
             * Method that is called when the translator needs to insert class instance scope variables.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preClassScopeVariables();

            /**
             * Method that is called when the translation needs to insert method definitions.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preMethodDeclarations();

            /**
             * Method that is called when the translator needs to insert the end of the model class declaration.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preEndModelClassDeclaration();

            /**
             * Method that is called when the translation needs to insert a thread definition.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preThreadDefinition();

            /**
             * Method that is called when the translator needs to insert thread scope local varaibles.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preThreadLocals();

            /**
             * Method that is called when the translator begins inserting thread scope the program implementation.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preThreadImplementation();

            /**
             * Method that is called when the translator begins inserting the thread post processing steps.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preThreadPostProcessing();

            /**
             * Method that is called when the translator begins inserting the thread cleanup steps.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preThreadCleanup();

            /**
             * Method that is called when the translator begins inserting the thread end code.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preThreadEnd();

            /**
             * Method that is called when the translator starts inserting method definitions.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preMethodDefinitions();

            /**
             * Method that is called when the translation needs to insert bookkeeping method definition.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preBookkeepingDefinition();

            /**
             * Method that is called when the translator inserts the model allocator function.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preModelAllocator();

            /**
             * Method that is called when the translator begins the convert IR to object phase.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preConvertIrToObject();

            /**
             * Method that is called when the translator begins the final link phase.
             *
             * \return Returns true on success, returns false on error.
             */
            bool preLink();

            /**
             * Virtual method you can overload to receive notification of diagnostic messages from the compiler.  Note
             * that the method may be called from a different thread than the one used to invoke the compiler.
             *
             * The default implementation simply returns without performing any additional function.
             *
             * \param[in] diagnostic The diagnostic information generated by the compiler.
             */
            void handleCompilerDiagnostic(const Cbe::CppCompilerDiagnostic& diagnostic);

            /**
             * Virtual method you can overload to receive notification when the compiler has finished.  Note that the
             * method may be called from a different thread than the one used to invoke the compiler.
             *
             * The default implementation simply returns.
             *
             * \param[in] success Holds true if the compiler completed successfully, returns false if an error is
             *                    reported.
             */
            void compilerFinished(bool success);

            /**
             * Virtual method you can overload to receive notification of diagnostic messages from the linker.  Note
             * that the method may be called from a different thread than the one used to invoke the linker.
             *
             * The default implementation simply returns without performing any additional function.
             *
             * \param[in] diagnosticMessage The diagnostic message generated by the linker.
             */
            void handleLinkerDiagnostic(const QString& diagnosticMessage);

            /**
             * Virtual method you can overload to receive notification when the linker has finished.  Note that the
             * method may be called from a different thread than the one used to invoke the linker.
             *
             * The default implementation simply returns.
             *
             * \param[in] success Holds true if the linker completed successfully, returns false if an error is
             *                    reported.
             */
            void linkerFinished(bool success);

            /**
             * Method you must overload to report a missing translator.
             *
             * \param[in] element The element that was missing a translator.
             *
             * \return Returns true if the code generator should abort.  Returns false if the code
             *         generator should ignore the missing translator and continue.  This version always returns true.
             */
            bool missingTranslator(ElementPointer element) final;

            /**
             * Method that creates a temporary filename.
             *
             * \param[in] suffix The suffix to append to the file.  Each temporary file must include a unique and
             *                   non-null suffix.
             *
             * \return Returns the name of a temporary file.
             */
            QString temporaryFilename(const QString& suffix);

            /**
             * Method that will attempt to delete a file if it exists.
             *
             * \param[in] filename The name of the file to delete.
             */
            static void deleteFileIfExists(const QString& filename);

            /**
             * Type used for the model allocator function.
             */
            typedef Model::Api* (*ModelAllocatorFunction)();

            /**
             * Type used for the model deallocator funciton.
             */
            typedef void (*ModelDeallocatorFunction)(Model::Api* model);

            /**
             * The name of the user module allocator function.
             */
            static const QString modelAllocatorFunctionName;

            /**
             * The name of the user model deallocator function.
             */
            static const QString modelDeallocatorFunctionName;

            /**
             * The current identifier database.
             */
            IdentifierDatabase& currentIdentifierDatabase;

            /**
             * The current stack slope.
             */
            ElementPointerList parentScopeStack;

            /**
             * Stack holding whether the scope should be forced aat this level.
             */
            QList<bool> parentScopeForcedStack;

            /**
             * The identifier representing the current scope.
             */
            ElementPointer currentScopeElement;

            /**
             * Flag indicating that the current scope should be forced for new variable/function assignments.
             */
            bool currentScopeForced;

            /**
             * Flag indicating if we're using the current variables as L values.
             */
            bool currentAsLValue;

            /**
             * Set of required header and PCH files.
             */
            QSet<QString> requiredHeaders;

            /**
             * Set of library dependencies.
             */
            QSet<QString> requiredLibraries;

            /**
             * The combined compiler and linker context.
             */
            QSharedPointer<CppContext> currentContext;

            /**
             * Temporary file used to generate the temporary object and dynamic library names.
             */
            QTemporaryFile temporaryFile;

            /**
             * The temporary filename to use for the object file.
             */
            QString objectFile;

            /**
             * Holds the status from the compiler or linker background threads.
             */
            bool backendWasSuccessful;

            /**
             * Semaphore used to block execution until the background thread completes.
             */
            QSemaphore backendSemaphore;
    };
};

#endif
